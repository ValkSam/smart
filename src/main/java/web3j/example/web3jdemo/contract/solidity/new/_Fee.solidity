pragma solidity ^0.4.23;

import 'browser/_Ownable.sol';
import 'browser/_Math.sol';
import 'browser/_SafeMath.sol';

contract Fee {

    using Math for uint256;

    struct FeeRule {
        uint32  userTypeSender;
        uint32  userTypeReceiver;
        uint256 amountFrom;
        uint256 amountTo;
        uint8   percent;
        uint256 fixedAmount;
        uint256 minAmount;
        uint256 maxAmount;
    }

    FeeRule[] private feeRules;

    constructor() public {
        feeRules.push(FeeRule(2001, 2001, 0, 0, 2, 3, 10, 20));
        feeRules.push(FeeRule(2002, 2001, 0, 0, 2, 0, 0, 20));
    }

    function countFee(uint32  userTypeSender, uint32  userTypeReceiver, uint256 amount) external view returns(uint256 result){
        FeeRule memory feeRule = getFeeRule(userTypeSender, userTypeReceiver, amount);
        if (feeRule.userTypeSender == address(0)) {
            return uint256(-1);
        }
        result = amount * feeRule.percent / 100 + feeRule.fixedAmount;
        result = result.max256(feeRule.minAmount);
        return feeRule.maxAmount == 0 ? result : result.min256(feeRule.maxAmount);
    }

    function getFeeRule(uint32  userTypeSender, uint32  userTypeReceiver, uint256 amount) private view returns(FeeRule) {
        for (uint256 i = 0; i < feeRules.length; i++) {
            if (feeRules[i].userTypeSender == userTypeSender && feeRules[i].userTypeReceiver == userTypeReceiver) {
                if (feeRules[i].amountTo == 0) {
                    return feeRules[i];
                }
                if (feeRules[i].amountFrom >= amount && amount <= feeRules[i].amountTo) {
                    return feeRules[i];
                }
            }
        }
    }

    mapping(uint256 => bool) uniqueRules;

    function checkRuls() internal
        returns(uint256)
    {
        for (uint256 i = 0; i < feeRules.length; i++) {
            FeeRule memory feeRule = feeRules[i];
            if (feeRule.userTypeSender == 0 || feeRule.userTypeReceiver == 0) {
                return i;
            }
            if (feeRule.amountFrom > feeRule.amountTo) {
                return i;
            }
            if (feeRule.maxAmount != 0 && feeRule.minAmount > feeRule.maxAmount) {
                return i;
            }
            if (feeRule.fixedAmount != 0 && feeRule.maxAmount != 0 && feeRule.fixedAmount > feeRule.maxAmount) {
                return i;
            }
            uint key = (uint128(feeRule.userTypeSender) << 98)
                        | (uint128(feeRule.userTypeReceiver) << 64)
                        | (uint128(feeRule.amountFrom) << 32)
                        | uint128(feeRule.amountFrom);
            if (uniqueRules[key]) {
                return i;
            }
            uniqueRules[key] = true;
        }
    }

}