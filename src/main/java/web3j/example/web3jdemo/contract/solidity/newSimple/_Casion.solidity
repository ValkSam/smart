pragma solidity ^0.4.23;

import 'browser/_Ownable.sol';
import 'browser/_Fee.sol';
import 'browser/_SafeMath.sol';
import 'browser/_Arrays.sol';

contract BasicToken is Ownable {

    using SafeMath for uint256;

    uint256 internal maxSupply_;
    uint256 internal totalSupply_;

    function totalSupply() public view returns(uint256);
    function setTotalSupply(uint256 amount) internal;

    function maxSupply() public view returns(uint256);
}

contract ManagingUser is BasicToken {

    enum UserKind {
        ADMIN, USER
    }

    struct UserData {
        bool    active;
        UserKind userKind;
        uint256 userType;
        uint256 balance;
        uint256 balanceReserved;
    }

    uint256 public usersNumber;
    mapping(address => UserData) internal users;

    event UserRegister(
        address indexed userAddress,
        UserKind indexed userKind,
        string details
        );

    event UserTypeSetting(
        address indexed userAddress,
        uint256 indexed prevType,
        uint256 indexed newType,
        string details
        );

    event UserActiveSetting(
        address indexed userAddress,
        bool indexed acive,
        string details
        );

    /*restricted*/

    function registerAdmin(address userAddress, uint32 userType, string details) external
        onlyOwner
    {
        registerUser(userAddress, UserKind.ADMIN, userType, details);
    }

    function registerUser(address userAddress, uint32 userType, string details) external
        onlyAdmin
    {
        registerUser(userAddress, UserKind.USER, userType, details);
    }

    function registerUser(address userAddress, UserKind userKind, uint32 userType, string details) internal {
        require(userAddress != address(0));
        require(userType != 0);
        require(users[userAddress].userType == 0);

        users[userAddress] = UserData(true, userKind, userType, 0, 0);

        usersNumber++;

        emit UserRegister (
            userAddress,
            userKind,
            details
            );

        emit UserTypeSetting (
            userAddress,
            0,
            userType,
            "init"
            );
    }

    function setUserTypeFor(address userAddress, uint32 userType, string details) external
        onlyAdmin
    {
        uint256 currUserType = users[userAddress].userType;
        require(currUserType != userType);
        users[userAddress].userType = userType;

        emit UserTypeSetting (
            userAddress,
            currUserType,
            userType,
            details
            );
    }

    function activateUser(address userAddress, string details) external
        onlyAdmin
    {
        setUserTypeFor(userAddress, true, details);
    }

    function deActivateUser(address userAddress, string details) external
        onlyAdmin
    {
        setUserTypeFor(userAddress, false, details);
    }

    function setUserTypeFor(address userAddress, bool active, string details) internal {
        require(users[userAddress].active != active);
        users[userAddress].active = active;

        emit UserActiveSetting (
            userAddress,
            active,
            details
            );
    }

    /*public*/

    function typeOf(address _address) external view
        returns(uint256)
    {
        return users[_address].userType;
    }

    function activeOf(address _address) public view
        returns(bool)
    {
        return users[_address].active;
    }

    /*modifier*/

    modifier onlyAdmin() {
        if (msg.sender != owner) {
            require (users[msg.sender].userKind == UserKind.ADMIN);
        }
        _;
    }

}

contract ManagingFee is Ownable {

     Fee internal fee;

     function registerFeeContract(address feeContractAddress) external
        onlyOwner
     {
         fee = Fee(feeContractAddress);
         require(fee.feeRulesVerified());
     }
}

contract Documenting {

    using Arrays for bytes32[];
    using Strings for string;

    mapping(address=>mapping(bytes32=>uint256)) internal docLogs;
    mapping(address=>bytes32[]) internal docLogsList;

    function documentsUIDs(address _address) public view
        returns (bytes32[] documentUIDs)
    {
        return docLogsList[_address];
    }

    function documentExists(address _address, string documentUID) public view
        returns(bool)
    {
        return documentAmount(_address, documentUID) != 0;
    }

    function documentAmount(address _address, string documentUID) public view
        returns(uint256)
    {
        return docLogs[_address][documentHash(documentUID)];
    }

    function addDocument(address _address, uint amount, string documentUID) internal
    {
        require(bytes(documentUID).length != 0);
        require(bytes(documentUID).length <= 32);
        require(amount > 0);
        require(!documentExists(_address, documentUID));
        bytes32 documentUIDHash = documentHash(documentUID);
        docLogs[_address][documentUIDHash] = amount;
        docLogsList[_address].push(documentUIDHash);
    }

    function removeDocument(address _address, string documentUID) internal
    {
        require(documentExists(_address, documentUID));
        bytes32 documentUIDHash = documentHash(documentUID);
        uint256 idx = docLogsList[_address].find(documentUIDHash);
        assert(idx != uint(-1));
        docLogsList[_address].remove(idx);
        delete docLogs[_address][documentUIDHash];
    }

    function documentHash(string document) internal pure
        returns(bytes32)
    {
        return document.stringToBytes32();
    }
}

contract OperatingUser is ManagingUser {

    function incBalance(address userAddress, uint256 amount) internal
        onlyForActiveUser(userAddress)
    {
        users[userAddress].balance.add(amount);
    }

    function decBalance(address userAddress, uint256 amount) internal
        onlyForActiveUser(userAddress)
    {
        users[userAddress].balance.sub(amount);
    }

    function incBalanceReserved(address userAddress, uint256 amount) internal
        onlyForActiveUser(userAddress)
    {
        users[userAddress].balanceReserved.add(amount);
    }

    function decBalanceReserved(address userAddress, uint256 amount) internal
        onlyForActiveUser(userAddress)
    {
        users[userAddress].balanceReserved.sub(amount);
    }

    modifier onlyForActiveUser(address userAddress) {
        require (activeOf(userAddress));
        _;
    }

}

contract Enrolling is Documenting, OperatingUser {

    event RegisterEnrollDocument(
        address indexed userAddress,
        string indexed documentUID,
        uint256 amount,
        string details
        );

    event Mint(
        address userAddress,
        uint256 amount,
        string indexed documentUID,
        string details
        );

    function registerEnrollRequest(address userAddress, uint256 amount, string documentUID, string details) external
        onlyAdmin
    {
        addDocument(userAddress, amount, documentUID);

        emit RegisterEnrollDocument(
            userAddress,
            documentUID,
            amount,
            details);
    }

    function enroll(address userAddress, string documentUID, string details) external
        onlyAdmin
    {
        uint256 currentTotalSupply = totalSupply();
        uint256 amount = documentAmount(userAddress, documentUID);
        require(currentTotalSupply + amount <= maxSupply());
        setTotalSupply(currentTotalSupply.add(amount));

        removeDocument(userAddress, documentUID);

        incBalance(userAddress, amount);

        emit Mint(
            userAddress,
            amount,
            documentUID,
            details);
    }

}

contract Withdrowing is Documenting, OperatingUser {

    event RegisterWithdrawDocument(
        address indexed userAddress,
        string indexed documentUID,
        uint256 amount,
        string details
        );

    event Burn(
        address indexed userAddress,
        uint256 amount,
        string indexed documentUID,
        string details
        );

    function registerWithdrawRequest(address userAddress, uint256 amount, string documentUID, string details) external
        onlyAdmin
    {
        addDocument(userAddress, amount, documentUID);

        decBalance(userAddress, amount);
        incBalanceReserved(userAddress, amount);

        emit RegisterWithdrawDocument(
            userAddress,
            documentUID,
            amount,
            details);
    }

    function withdraw(address userAddress, string documentUID, string details) external
        onlyAdmin
    {
        uint256 currentTotalSupply = totalSupply();
        uint256 amount = documentAmount(userAddress, documentUID);
        setTotalSupply(currentTotalSupply.sub(amount));

        removeDocument(userAddress, documentUID);

        decBalanceReserved(userAddress, amount);

        emit Burn(
            userAddress,
            amount,
            documentUID,
            details);
    }

}

contract Casion is Enrolling, Withdrowing, ManagingFee {

    function balanceOf(address _address) external view
        returns (uint256)
    {
        return users[_address].balance;
    }

    function balanceResirvedOf(address _address) external view
        returns (uint256)
    {
        return users[_address].balance;
    }

    function maxSupply() public view
        returns (uint256)
    {
        return maxSupply_;
    }

    function totalSupply() public view
        returns (uint256)
    {
        return totalSupply_;
    }

    function setTotalSupply(uint256 amount) internal {
        totalSupply_ = amount;
    }

    function transferFrom(address _from, address _to, int amount, string details) external
        onlyAdmin
    {
        // transferFromTo(_from, _to, amount, details);
    }


    function getFeeValue(address sender, address receiver, uint256 amount) external view returns(uint256 result){
        result = fee.countFee(
                users[sender].userType,
                users[receiver].userType,
                amount
            );
        assert(result != uint256(-1));
    }

}