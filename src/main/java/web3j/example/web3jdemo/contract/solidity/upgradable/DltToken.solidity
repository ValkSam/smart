pragma solidity ^0.4.23;

import "browser/Libs.sol";
import "browser/Events.sol";
import "browser/DltAdmin.sol";
import "browser/DltCasino.sol";
import "browser/DltUser.sol";

contract Token is eventRegisterAware, eventTransferAware, eventExchangeAware, eventMintAware, eventRegisterDocumentAware {

    string private ROOT_KEY = 'token.';
    bytes32 TOTAL_SYPPLY_KEY_HASH = keccak256(ROOT_KEY, 'ERC20.totalSupply');

    Storage private _storage;

    constructor (address storageContractAddress, string _name, string _symbol, uint _maxSupply, uint _decimals) public {
        _storage = Storage(storageContractAddress);
        require(msg.sender == _storage.owner());
        name = _name;
        symbol = _symbol;
        maxSupply = _maxSupply;
        decimals = _decimals;
    }

    /*ERC20 ... */

    string public name;
    string public symbol;
    uint public maxSupply;
    uint public decimals;

    function totalSupply() public view returns(uint) {
        return _storage.getUint(TOTAL_SYPPLY_KEY_HASH);
    }

    function balanceOf(address userAddress) external view returns(uint) {
        return getUserContract().balanceOf(userAddress);
    }

    function transfer(address _to, uint amount, string details) external {
        address _from = msg.sender;
        transferFromTo(_from, _to, amount, details);
    }

    function transferFrom(address _from, address _to, uint amount, string details) external
        onlyByAdmin
    {
        transferFromTo(_from, _to, amount, details);
    }

    function approve(address _spender, uint amount) external pure returns (bool success) {
        return false; //not supported
    }

    function allowance(address userAddress, address _spender) external view returns (uint) {
        address adminAddress = _storage.getPermittedContractAddress(ContractType.ADMIN);
        Admin admin = Admin(adminAddress);
        if (admin.isAdmin(_spender)) {
            return getUserContract().balanceOf(userAddress);
        } else {
            return 0;
        }
    }

    /* ... ERC20*/

    /*public*/

    function isLatestVersion() external view
        returns (bool) {
        return _storage.isPermittedContractAddress(address(this));
    }

    function checkContractType(ContractType contractType) external pure {
        require(contractType == ContractType.TOKEN);
    }

    /*admin permissions*/

    function registerEnrollRequestDocument(address userAddress, uint amount, string documentUID, string details) external
        onlyByAdmin
    {
        require(amount > 0);

        User user = getUserContract();
        user.addDocument(userAddress, documentUID, amount);

        emit RegisterDocument(
            TransactionType.ENROLL_REQUEST,
            userAddress,
            documentUID,
            amount,
            details);
    }

    function cancelEnrollRequestDocument(address userAddress, uint amount, string documentUID, string details) external
        onlyByAdmin
    {
        User user = getUserContract();
        user.removeDocument(userAddress, documentUID);

        emit RegisterDocument(
            TransactionType.CANCEL_ENROLL_REQUEST,
            userAddress,
            documentUID,
            amount,
            details);
    }


    function registerWithdrawRequestDocument(address userAddress, uint amount, string documentUID, string details) external
        onlyByAdmin
    {
        require(amount > 0);

        User user = getUserContract();
        user.addDocument(userAddress, documentUID, amount);
        user.balanceChange(userAddress, (-amount));
        user.balanceReservedChange(userAddress, amount);

        emit RegisterDocument(
            TransactionType.WITHDRAW_REQUEST,
            userAddress,
            documentUID,
            amount,
            details);
    }

    function enroll(address userAddress, uint amount, string documentUID, string details) external
        onlyByAdmin
    {
        require(amount > 0);
        uint currentTotalSupply = totalSupply();
        require(currentTotalSupply + amount <= maxSupply);

        User user = getUserContract();
        user.removeDocument(userAddress, documentUID);

        user.balanceChange(userAddress, amount);
        setTotalSupply(currentTotalSupply + amount);

        emit Mint(
            TransactionType.ENROLL,
            userAddress,
            userAddress,
            amount,
            documentUID,
            details);
    }

    function withdraw(address userAddress, uint amount, string documentUID, string details) external
        onlyByAdmin
    {
        require(amount > 0);
        uint currentTotalSupply = totalSupply();
        assert(currentTotalSupply - amount >= 0);

        User user = getUserContract();
        user.removeDocument(userAddress, documentUID);

        user.balanceReservedChange(userAddress, (-amount));
        setTotalSupply(currentTotalSupply - amount);

        emit Burn(
            TransactionType.WITHDRAW,
            userAddress,
            user.getReservedAddress(userAddress),
            amount,
            documentUID,
            details);
    }

    function depositCoin(address userAddress, address casinoAddress, uint amount, string documentUID, string details) public
        onlyByAdmin
    {
        exchangeCoin(TransactionType.DEPOSIT, userAddress, casinoAddress, amount, documentUID, details);
    }

    function takeCoin(address userAddress, address casinoAddress, uint amount, string documentUID, string details) public
        onlyByAdmin
    {
        exchangeCoin(TransactionType.TAKE, userAddress, casinoAddress, amount, documentUID, details);
    }

    /*private section*/

    function exchangeCoin(TransactionType transactionType, address userAddress, address casinoAddress, uint amount, string documentUID, string details) private {
        require(amount > 0);

        Casino casino = getCasinoContract();
        User user = getUserContract();

        if (transactionType == TransactionType.DEPOSIT){
            casino.balanceChange(casinoAddress, amount);
            user.balanceChange(userAddress, (-amount));
        } else if (transactionType == TransactionType.TAKE) {
            casino.balanceChange(casinoAddress, (-amount));
            user.balanceChange(userAddress, amount);
        } else {
            revert();
        }

        emit Exchange(
            transactionType,
            userAddress,
            casinoAddress,
            amount,
            documentUID,
            details);
    }

    function getAdminContract() private view returns(Admin) {
        address adminAddress = _storage.getPermittedContractAddress(ContractType.ADMIN);
        return Admin(adminAddress);
    }

    function getCasinoContract() private view returns(Casino) {
        address casinoAddress = _storage.getPermittedContractAddress(ContractType.CASINO);
        return Casino(casinoAddress);
    }

    function getUserContract() private view returns(User) {
        address userAddress = _storage.getPermittedContractAddress(ContractType.USER);
        return User(userAddress);
    }

    function transferFromTo(address _from, address _to, uint amount, string details) private
    {
        require(amount > 0);

        User user = getUserContract();

        user.balanceChange(_from, (-amount));
        user.balanceChange(_to, amount);

        emit Transfer(
            _from,
            _to,
            TransactionType.TRANSFER,
            amount,
            details);
    }

    function setTotalSupply(uint amount) private {
        _storage.setUint(TOTAL_SYPPLY_KEY_HASH, amount);
    }

    /*modifier*/

    modifier onlyByAdmin() {
        address adminAddress = _storage.getPermittedContractAddress(ContractType.ADMIN);
        Admin admin = Admin(adminAddress);
        require (admin.isAdmin(msg.sender));
        _;
    }

}
