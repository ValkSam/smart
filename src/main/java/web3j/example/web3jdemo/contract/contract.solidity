pragma solidity ^0.4.21;

contract root {
    address private rooter;
    
    function root() public{
        rooter = msg.sender;
    }
    
    function getRooter() public view returns(address){
        return rooter;
    }
    
    modifier onlyRoot {
        require (msg.sender == rooter);
        _;
    }
}

contract user {
    
    struct Balance {
        address addr;
        uint amount;
    }
    
    struct UserBalance {
        Balance active;
        Balance passive;
    }

    struct DocLog {
        uint blockNumber;
        uint amount;
    }

    struct UserData {
        UserBalance balance;
        mapping(bytes32 => DocLog) docLog;
    }

    mapping (address => UserData) users;

    modifier onlyByUser(address indexAddress) {
        require (msg.sender == indexAddress);
        _;
    }

    modifier onlyByUserFromActive(address indexAddress) {
        require (msg.sender == users[indexAddress].balance.active.addr);
        _;
    }

    modifier onlyByUserFromPassive(address indexAddress) {
        require (msg.sender == users[indexAddress].balance.passive.addr);
        _;
    }

    modifier onlyExistedUser(address indexAddress) {
        require(users[indexAddress].balance.active.addr != address(0x0));
        _;
    }

    modifier onlyUniqueDocument(address indexAddress, string documentUID) {
        bytes32 documentUIDHash = keccak256(documentUID);
        require(users[indexAddress].docLog[documentUIDHash].blockNumber == 0);
        _;
    }

    modifier onlyExistedDocument(address indexAddress, string documentUID, uint amount) {
        require(users[indexAddress].docLog[keccak256(documentUID)].blockNumber != 0);
        require(users[indexAddress].docLog[keccak256(documentUID)].amount == amount);
        _;
    }
}

contract document {

    struct Document {
        string uid;
        string details;
    }

    modifier onlyDocumented(string documentUID) {
        require(bytes(documentUID).length != 0);
        _;
    }
}


contract DLT_5 is root, user, document{



    mapping (address => uint) casinos;



    enum ErrorCodes {
        NOT_ROOT, ALREADY_EXISTS
    }

    enum TransactionType {
        REGISTER_USER, TRANSFER, MINT, ENROLL, BURN, USE, RETURN, HOLD
    }

    function DLT_5() public {

    }

    event Transaction(
        TransactionType txType,
        address user,
        address sender,
        address receiver,
        uint amount,
        string documentUID,
        string details
        );

    function addCasino(address casinoAddress) public
        onlyRoot
    {
        require (casinos[casinoAddress] == 0);
        casinos[casinoAddress] = 0;
    }

    function registerUser(address indexAddress, address active, address passive, string documentUID, string details) public
        onlyRoot
    {
        require(users[indexAddress].balance.active.addr == address(0x0));
        require(indexAddress != active);
        require(indexAddress != passive);
        require(active != passive);

        users[indexAddress] = UserData(UserBalance(Balance(active, 0), Balance(passive, 0)));

        emit Transaction(
            TransactionType.REGISTER_USER,
            indexAddress,
            users[indexAddress].balance.active.addr,
            users[indexAddress].balance.passive.addr,
            0,
            documentUID,
            details);
    }

    function enrollRequest(address indexAddress, uint amount, string documentUID, string details) public
        onlyByUser(indexAddress)
        onlyExistedUser (indexAddress)
        onlyDocumented(documentUID)
        onlyUniqueDocument(indexAddress, documentUID)
    {
        require(amount > 0);

        users[indexAddress].balance.passive.amount += amount;
        users[indexAddress].docLog[keccak256(documentUID)] = DocLog(block.number, amount);

        emit Transaction(
            TransactionType.MINT,
            indexAddress,
            indexAddress,
            users[indexAddress].balance.passive.addr,
            amount,
            documentUID,
            details);
    }

    function enroll(address indexAddress, uint amount, string documentUID, string details) public
        onlyByUserFromPassive(indexAddress)
        onlyExistedUser (indexAddress)
        onlyExistedDocument(indexAddress, documentUID, amount)
    {
        require(amount > 0);
        require(users[indexAddress].balance.passive.amount >= amount);

        moveToActive(indexAddress, amount);
        delete(users[indexAddress].docLog[keccak256(documentUID)]);

        emit Transaction(
            TransactionType.ENROLL,
            indexAddress,
            users[indexAddress].balance.passive.addr,
            users[indexAddress].balance.active.addr,
            amount,
            documentUID,
            details);
    }

    function moveToActive(address indexAddress, uint amount) private {
        users[indexAddress].balance.passive.amount -= amount;
        users[indexAddress].balance.active.amount += amount;
    }

    function getActiveAddress(address indexAddress) public view
        onlyRoot
        returns (address active)
    {
        return users[indexAddress].balance.active.addr;
    }

    function getActiveBalance(address indexAddress) public view
        onlyRoot
        returns (uint amount)
    {
        return users[indexAddress].balance.active.amount;
    }

    function getPassiveAddress(address indexAddress) public view
        onlyRoot
        returns (address passive)
    {
        return users[indexAddress].balance.passive.addr;
    }
    
    function getPassiveBalance(address indexAddress) public view 
        onlyRoot
        returns (uint amount) 
    {
        return users[indexAddress].balance.passive.amount;
    }
    
    function getDocumentGenerationBlock(address indexAddress, string documentUID) public view 
        onlyRoot
        returns (uint blockNumber) 
    {
        return users[indexAddress].docLog[keccak256(documentUID)].blockNumber;
    }

}