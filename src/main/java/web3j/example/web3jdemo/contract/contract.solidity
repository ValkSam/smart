pragma solidity ^0.4.21;


contract root {
    address private rooter;

    function root() public{
        rooter = msg.sender;
    }

    function getRooter() public view returns(address){
        return rooter;
    }

    modifier onlyRoot {
        require (msg.sender == rooter);
        _;
    }
}

contract eventAware {

    enum TransactionType {
        REGISTER_CASINO, REGISTER_USER, TRANSFER, MINT, ENROLL, BURN, DEPOSIT, WITHDRAW, HOLD
    }

    event Transaction(
        TransactionType txType,
        address user,
        address sender,
        address receiver,
        uint amount,
        string documentUID,
        string details
        );

}

contract user is eventAware {

    struct Balance {
        address addr;
        uint amount;
    }

    struct UserBalance {
        Balance active;
        Balance passive;
    }

    struct DocLog {
        uint blockNumber;
        uint amount;
    }

    struct UserData {
        bool isActive;
        UserBalance balance;
        bytes32[] docLogIndex;
        mapping(bytes32 => DocLog) docLog;
    }

    mapping (address => UserData) users;
    address[] usersIndex;

    function registerMeAsUser(address indexAddress, address active, address passive, string documentUID, string details) public
        onlyByUser(indexAddress)
    {
        require(users[indexAddress].balance.active.addr == address(0x0));
        require(indexAddress != active);
        require(indexAddress != passive);
        require(active != passive);

        usersIndex.push(indexAddress);
        users[indexAddress] = UserData(
            {
                isActive: true,
                balance: UserBalance(Balance(active, 0), Balance(passive, 0)),
                docLogIndex: new bytes32[](0)
            });

        emit Transaction(
            TransactionType.REGISTER_USER,
            indexAddress,
            users[indexAddress].balance.active.addr,
            users[indexAddress].balance.passive.addr,
            0,
            documentUID,
            details);
    }

    modifier onlyByUser(address indexAddress) {
        require (msg.sender == indexAddress);
        _;
    }

    modifier onlyByUserFromActive(address indexAddress) {
        require (msg.sender == users[indexAddress].balance.active.addr);
        require (users[indexAddress].isActive);
        _;
    }

    modifier onlyByUserFromPassive(address indexAddress) {
        require (msg.sender == users[indexAddress].balance.passive.addr);
        require (users[indexAddress].isActive);
        _;
    }

    modifier onlyExistedUser(address indexAddress) {
        require(users[indexAddress].balance.active.addr != address(0x0));
        require (users[indexAddress].isActive);
        _;
    }

    modifier onlyUniqueDocument(address indexAddress, string documentUID) {
        bytes32 documentUIDHash = keccak256(documentUID);
        require(users[indexAddress].docLog[documentUIDHash].blockNumber == 0);
        _;
    }

    modifier onlyExistedDocument(address indexAddress, string documentUID, uint amount) {
        require(users[indexAddress].docLog[keccak256(documentUID)].blockNumber != 0);
        require(users[indexAddress].docLog[keccak256(documentUID)].amount == amount);
        _;
    }
}

contract casino is eventAware{

    struct CasinoData {
        bool isActive;
        uint amount;
    }

    function registerMeAsCasino(address casinoAddress, string documentUID, string details) public
        onlyByCasino(casinoAddress)
    {
        require(getArrayItemIndex(casinosIndex, casinoAddress) == uint(-1));

        casinosIndex.push(casinoAddress);
        casinos[casinoAddress] = CasinoData(
            {
                isActive: true,
                amount: 0
            });

        emit Transaction(
            TransactionType.REGISTER_CASINO,
            casinoAddress,
            casinoAddress,
            casinoAddress,
            0,
            documentUID,
            details);
    }

    function getArrayItemIndex(address[] storage self, address value) private view returns (uint index){

        bytes32 valueToSearch = keccak256(value);

        for (uint i = 0; i<self.length; i++){
            if (keccak256(self[i]) == valueToSearch){
                return i;
                break;
            }
        }

        return uint(-1);
    }

    mapping(address => CasinoData) casinos;
    address[] casinosIndex;

    modifier onlyByCasino(address casinoAddress) {
        require (msg.sender == casinoAddress);
        _;
    }

    modifier onlyExistedCasino(address casinoAddress) {
        require(casinos[casinoAddress].isActive);
        _;
    }

}

contract document {

    struct Document {
        string uid;
        string details;
    }

    modifier onlyDocumented(string documentUID) {
        require(bytes(documentUID).length != 0);
        require(bytes(documentUID).length <= 32);
        _;
    }
}


contract DLT_5 is root, user, document, casino{

    function DLT_5() public {

    }

    function enrollRequest(address indexAddress, uint amount, string documentUID, string details) public
        onlyByUser(indexAddress)
        onlyDocumented(documentUID)
        onlyUniqueDocument(indexAddress, documentUID)
    {
        require(amount > 0);

        users[indexAddress].balance.passive.amount += amount;
        users[indexAddress].docLog[keccak256(documentUID)] = DocLog(block.number, amount);
        users[indexAddress].docLogIndex.push(stringToBytes32(documentUID));

        emit Transaction(
            TransactionType.MINT,
            indexAddress,
            indexAddress,
            users[indexAddress].balance.passive.addr,
            amount,
            documentUID,
            details);
    }

    function enroll(address indexAddress, uint amount, string documentUID, string details) public
        onlyByUserFromPassive(indexAddress)
        onlyExistedDocument(indexAddress, documentUID, amount)
    {
        require(amount > 0);
        require(users[indexAddress].balance.passive.amount >= amount);

        removeFromDocLog(indexAddress, documentUID);

        moveToActive(indexAddress, amount);

        emit Transaction(
            TransactionType.ENROLL,
            indexAddress,
            users[indexAddress].balance.passive.addr,
            users[indexAddress].balance.active.addr,
            amount,
            documentUID,
            details);
    }

    function depositCoin(address indexAddress, address casinoAddress, uint amount, string documentUID, string details) public
        onlyByUserFromActive(indexAddress)
        onlyExistedCasino(casinoAddress)
    {
        require(amount > 0);
        require(users[indexAddress].balance.active.amount >= amount);

        casinos[casinoAddress].amount += amount;
        users[indexAddress].balance.active.amount -= amount;

        emit Transaction(
            TransactionType.DEPOSIT,
            indexAddress,
            users[indexAddress].balance.active.addr,
            casinoAddress,
            amount,
            documentUID,
            details);
    }

    function withdrawCoin(address indexAddress, address casinoAddress, uint amount, string documentUID, string details) public
        onlyByUserFromActive(indexAddress)
        onlyExistedCasino(casinoAddress)
    {
        require(amount > 0);
        require(casinos[casinoAddress].amount >= amount);

        casinos[casinoAddress].amount -= amount;
        users[indexAddress].balance.active.amount += amount;

        emit Transaction(
            TransactionType.WITHDRAW,
            indexAddress,
            casinoAddress,
            users[indexAddress].balance.active.addr,
            amount,
            documentUID,
            details);
    }

    function removeFromDocLog(address indexAddress, string documentUID) private {
        uint idx = getArrayItemIndex(users[indexAddress].docLogIndex, documentUID);
        assert(idx == uint(-1));
        delete(users[indexAddress].docLog[keccak256(documentUID)]);
        removeArrayItem(users[indexAddress].docLogIndex, idx);
    }

    function moveToActive(address indexAddress, uint amount) private {
        users[indexAddress].balance.passive.amount -= amount;
        users[indexAddress].balance.active.amount += amount;
    }

    function getActiveAddress(address indexAddress) public view
        onlyRoot
        returns (address active)
    {
        return users[indexAddress].balance.active.addr;
    }

    function getActiveBalance(address indexAddress) public view
        onlyRoot
        returns (uint amount)
    {
        return users[indexAddress].balance.active.amount;
    }

    function getPassiveAddress(address indexAddress) public view
        onlyRoot
        returns (address passive)
    {
        return users[indexAddress].balance.passive.addr;
    }

    function getPassiveBalance(address indexAddress) public view
        onlyRoot
        returns (uint amount)
    {
        return users[indexAddress].balance.passive.amount;
    }

    function getDocumentGenerationBlock(address indexAddress, string documentUID) public view
        onlyRoot
        returns (uint blockNumber)
    {
        return users[indexAddress].docLog[keccak256(documentUID)].blockNumber;
    }

    function getDocumentsUIDs(address indexAddress) public view
        onlyRoot
        returns (bytes32[] documentUIDs)
    {
        return users[indexAddress].docLogIndex;
    }

    function stringToBytes32(string self) private pure returns (bytes32 result) {
        if (bytes(self).length == 0) {
            return "";
        }

        assembly {
            result := mload(add(self, 32))
        }
    }

    function getArrayItemIndex(bytes32[] storage self, string value) private view returns (uint index){
        bytes32 valueToSearch = stringToBytes32(value);

        for (uint i = 0; i<self.length; i++){
            if (self[i] == valueToSearch){
                return i;
                break;
            }
        }

        return uint(-1);
    }

    function removeArrayItem(bytes32[] storage self, uint index) private {
        if (index >= self.length) return;

        for (uint i = index; i<self.length-1; i++){
            self[i] = self[i+1];
        }

        self.length--;
    }


}